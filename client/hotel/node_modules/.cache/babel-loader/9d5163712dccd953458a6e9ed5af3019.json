{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.any = exports.json = exports.inputFile = exports.float = exports.int = exports.boolean = exports.string = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\n\n\nexports.string = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName, value) => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.string.name\n      });\n    }\n  }\n};\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\n\nexports.boolean = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\"\n    });\n  },\n\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName, value) => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.boolean.name\n      });\n    }\n  }\n};\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\n\nexports.int = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName, value) => {\n    const isInt = Number.isInteger(value);\n\n    if (!isInt) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n  }\n};\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\n\nexports.float = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName, value) => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n  }\n};\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\n\nexports.inputFile = {\n  name: \"inputFile\",\n\n  parse(argName, strValue) {\n    try {\n      fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {\n          name: argName,\n          value: strValue\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName, value) => {\n    try {\n      exports.inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n          value,\n          name: argName,\n          type: exports.inputFile.name\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n};\nexports.json = {\n  name: \"json\",\n\n  parse(argName, strValue) {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT, {\n          param: argName,\n          error: error.message\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName, value) => {\n    if (value === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.json.name\n      });\n    }\n  }\n};\nexports.any = {\n  name: \"any\",\n\n  validate(_argName, _argumentValue) {}\n\n};","map":{"version":3,"sources":["../../../src/internal/core/params/argumentTypes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.any = exports.json = exports.inputFile = exports.float = exports.int = exports.boolean = exports.string = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\nexports.string = {\n    name: \"string\",\n    parse: (argName, strValue) => strValue,\n    /**\n     * Check if argument value is of type \"string\"\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"string\"\n     */\n    validate: (argName, value) => {\n        const isString = typeof value === \"string\";\n        if (!isString) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: exports.string.name,\n            });\n        }\n    },\n};\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\nexports.boolean = {\n    name: \"boolean\",\n    parse: (argName, strValue) => {\n        if (strValue.toLowerCase() === \"true\") {\n            return true;\n        }\n        if (strValue.toLowerCase() === \"false\") {\n            return false;\n        }\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n            value: strValue,\n            name: argName,\n            type: \"boolean\",\n        });\n    },\n    /**\n     * Check if argument value is of type \"boolean\"\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"boolean\"\n     */\n    validate: (argName, value) => {\n        const isBoolean = typeof value === \"boolean\";\n        if (!isBoolean) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: exports.boolean.name,\n            });\n        }\n    },\n};\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\nexports.int = {\n    name: \"int\",\n    parse: (argName, strValue) => {\n        const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n        const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n        if (strValue.match(decimalPattern) === null &&\n            strValue.match(hexPattern) === null) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value: strValue,\n                name: argName,\n                type: exports.int.name,\n            });\n        }\n        return Number(strValue);\n    },\n    /**\n     * Check if argument value is of type \"int\"\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"int\"\n     */\n    validate: (argName, value) => {\n        const isInt = Number.isInteger(value);\n        if (!isInt) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: exports.int.name,\n            });\n        }\n    },\n};\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\nexports.float = {\n    name: \"float\",\n    parse: (argName, strValue) => {\n        const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n        const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n        if (strValue.match(decimalPattern) === null &&\n            strValue.match(hexPattern) === null) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value: strValue,\n                name: argName,\n                type: exports.float.name,\n            });\n        }\n        return Number(strValue);\n    },\n    /**\n     * Check if argument value is of type \"float\".\n     * Both decimal and integer number values are valid.\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"number\"\n     */\n    validate: (argName, value) => {\n        const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n        if (!isFloatOrInteger) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: exports.float.name,\n            });\n        }\n    },\n};\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\nexports.inputFile = {\n    name: \"inputFile\",\n    parse(argName, strValue) {\n        try {\n            fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);\n            const stats = fs.lstatSync(strValue);\n            if (stats.isDirectory()) {\n                // This is caught and encapsulated in a hardhat error.\n                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n                throw new Error(`${strValue} is a directory, not a file`);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {\n                    name: argName,\n                    value: strValue,\n                }, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n        return strValue;\n    },\n    /**\n     * Check if argument value is of type \"inputFile\"\n     * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"inputFile\"\n     */\n    validate: (argName, value) => {\n        try {\n            exports.inputFile.parse(argName, value);\n        }\n        catch (error) {\n            // the input value is considered invalid, throw error.\n            if (error instanceof Error) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                    value,\n                    name: argName,\n                    type: exports.inputFile.name,\n                }, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    },\n};\nexports.json = {\n    name: \"json\",\n    parse(argName, strValue) {\n        try {\n            return JSON.parse(strValue);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT, {\n                    param: argName,\n                    error: error.message,\n                }, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    },\n    /**\n     * Check if argument value is of type \"json\". We consider everything except\n     * undefined to be json.\n     *\n     * @param argName {string} argument's name - used for context in case of error.\n     * @param value {any} argument's value to validate.\n     *\n     * @throws HH301 if value is not of type \"json\"\n     */\n    validate: (argName, value) => {\n        if (value === undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n                value,\n                name: argName,\n                type: exports.json.name,\n            });\n        }\n    },\n};\nexports.any = {\n    name: \"any\",\n    validate(_argName, _argumentValue) { },\n};\n//# sourceMappingURL=argumentTypes.js.map"]},"metadata":{},"sourceType":"script"}