{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst mkdirpSync = require('../mkdirs').mkdirsSync;\n\nconst utimesSync = require('../util/utimes.js').utimesMillisSync;\n\nconst notExist = Symbol('notExist');\n\nfunction copySync(src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`);\n  }\n\n  const destStat = checkPaths(src, dest);\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent);\n  return startCopy(destStat, src, dest, opts);\n}\n\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  return getStats(destStat, src, dest, opts);\n}\n\nfunction getStats(destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const srcStat = statSync(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}\n\nfunction copyFile(srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest);\n    fs.chmodSync(dest, srcStat.mode);\n\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime);\n    }\n\n    return;\n  }\n\n  return copyFileFallback(srcStat, src, dest, opts);\n}\n\nfunction copyFileFallback(srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024;\n\n  const _buff = require('../util/buffer')(BUF_LENGTH);\n\n  const fdr = fs.openSync(src, 'r');\n  const fdw = fs.openSync(dest, 'w', srcStat.mode);\n  let pos = 0;\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, _buff, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);\n  fs.closeSync(fdr);\n  fs.closeSync(fdw);\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts);\n\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n  }\n\n  return copyDir(src, dest, opts);\n}\n\nfunction mkDirAndCopy(srcStat, src, dest, opts) {\n  fs.mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return fs.chmodSync(dest, srcStat.mode);\n}\n\nfunction copyDir(src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));\n}\n\nfunction copyDirItem(item, src, dest, opts) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  const destStat = checkPaths(srcItem, destItem);\n  return startCopy(destStat, srcItem, destItem, opts);\n}\n\nfunction onLink(destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src);\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n\n  if (destStat === notExist) {\n    return fs.symlinkSync(resolvedSrc, dest);\n  } else {\n    let resolvedDest;\n\n    try {\n      resolvedDest = fs.readlinkSync(dest);\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);\n      throw err;\n    }\n\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest);\n    }\n\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n    } // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n\n\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n    }\n\n    return copyLink(resolvedSrc, dest);\n  }\n}\n\nfunction copyLink(resolvedSrc, dest) {\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrc, dest);\n} // return true if dest is a subdir of src, otherwise false.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArray = path.resolve(src).split(path.sep);\n  const destArray = path.resolve(dest).split(path.sep);\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);\n}\n\nfunction checkStats(src, dest) {\n  const srcStat = fs.statSync(src);\n  let destStat;\n\n  try {\n    destStat = fs.statSync(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: notExist\n    };\n    throw err;\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n}\n\nfunction checkPaths(src, dest) {\n  const {\n    srcStat,\n    destStat\n  } = checkStats(src, dest);\n\n  if (destStat.ino && destStat.ino === srcStat.ino) {\n    throw new Error('Source and destination must not be the same.');\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);\n  }\n\n  return destStat;\n}\n\nmodule.exports = copySync;","map":{"version":3,"sources":["/Users/macbook/Desktop/Projects/Hotel-management-Mern-stack-/client/hotel/node_modules/hardhat/node_modules/fs-extra/lib/copy-sync/copy-sync.js"],"names":["fs","require","path","mkdirpSync","mkdirsSync","utimesSync","utimesMillisSync","notExist","Symbol","copySync","src","dest","opts","filter","clobber","overwrite","preserveTimestamps","process","arch","console","warn","destStat","checkPaths","destParent","dirname","existsSync","startCopy","getStats","statSync","dereference","lstatSync","srcStat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","copyFile","mayCopyFile","unlinkSync","errorOnExist","Error","copyFileSync","chmodSync","mode","atime","mtime","copyFileFallback","BUF_LENGTH","_buff","fdr","openSync","fdw","pos","size","bytesRead","readSync","writeSync","futimesSync","closeSync","mkDirAndCopy","copyDir","mkdirSync","readdirSync","forEach","item","copyDirItem","srcItem","join","destItem","resolvedSrc","readlinkSync","resolve","cwd","symlinkSync","resolvedDest","err","code","isSrcSubdir","copyLink","srcArray","split","sep","destArray","reduce","acc","current","i","checkStats","ino","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\n\nconst notExist = Symbol('notExist')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const destStat = checkPaths(src, dest)\n\n  if (opts.filter && !opts.filter(src, dest)) return\n\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const destStat = checkPaths(srcItem, destItem)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (destStat === notExist) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest) {\n  const srcStat = fs.statSync(src)\n  let destStat\n  try {\n    destStat = fs.statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}\n    throw err\n  }\n  return {srcStat, destStat}\n}\n\nfunction checkPaths (src, dest) {\n  const {srcStat, destStat} = checkStats(src, dest)\n  if (destStat.ino && destStat.ino === srcStat.ino) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n  }\n  return destStat\n}\n\nmodule.exports = copySync\n"]},"metadata":{},"sourceType":"script"}