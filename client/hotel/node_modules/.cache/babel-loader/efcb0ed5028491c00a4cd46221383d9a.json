{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertHardhatInvariant = exports.applyErrorMessageTemplate = exports.NomicLabsHardhatPluginError = exports.HardhatPluginError = exports.HardhatError = exports.CustomError = void 0;\n\nconst caller_package_1 = require(\"../util/caller-package\");\n\nconst strings_1 = require(\"../util/strings\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nclass CustomError extends Error {\n  constructor(message, parent) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    super(message);\n    this.parent = parent;\n    this.name = this.constructor.name; // We do this to avoid including the constructor in the stack trace\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this._stack = this.stack ?? \"\";\n    Object.defineProperty(this, \"stack\", {\n      get: () => this[inspect]()\n    });\n  }\n\n  [inspect]() {\n    let str = this._stack;\n\n    if (this.parent !== undefined) {\n      const parentAsAny = this.parent;\n      const causeString = parentAsAny[inspect]?.() ?? parentAsAny.inspect?.() ?? parentAsAny.stack ?? parentAsAny.toString();\n      const nestedCauseStr = causeString.split(\"\\n\").map(line => `    ${line}`).join(\"\\n\").trim();\n      str += `\n\n    Caused by: ${nestedCauseStr}`;\n    }\n\n    return str;\n  }\n\n}\n\nexports.CustomError = CustomError;\n\nclass HardhatError extends CustomError {\n  constructor(errorDescriptor) {\n    let messageArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parentError = arguments.length > 2 ? arguments[2] : undefined;\n    const prefix = `${(0, errors_list_1.getErrorCode)(errorDescriptor)}: `;\n    const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);\n    super(prefix + formattedMessage, parentError);\n    this.errorDescriptor = errorDescriptor;\n    this.number = errorDescriptor.number;\n    this.messageArguments = messageArguments;\n    this._isHardhatError = true;\n    Object.setPrototypeOf(this, HardhatError.prototype);\n  }\n\n  static isHardhatError(other) {\n    return other !== undefined && other !== null && other._isHardhatError === true;\n  }\n\n  static isHardhatErrorType(other, descriptor) {\n    return HardhatError.isHardhatError(other) && other.errorDescriptor.number === descriptor.number;\n  }\n\n}\n\nexports.HardhatError = HardhatError;\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\n\nclass HardhatPluginError extends CustomError {\n  constructor(pluginNameOrMessage, messageOrParent, parent) {\n    if (typeof messageOrParent === \"string\") {\n      super(messageOrParent, parent);\n      this.pluginName = pluginNameOrMessage;\n    } else {\n      super(pluginNameOrMessage, messageOrParent);\n      this.pluginName = (0, caller_package_1.getClosestCallerPackage)();\n    }\n\n    this._isHardhatPluginError = true;\n    Object.setPrototypeOf(this, HardhatPluginError.prototype);\n  }\n\n  static isHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isHardhatPluginError === true;\n  }\n\n}\n\nexports.HardhatPluginError = HardhatPluginError;\n\nclass NomicLabsHardhatPluginError extends HardhatPluginError {\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  constructor(pluginName, message, parent) {\n    let shouldBeReported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(pluginName, message, parent);\n    this.shouldBeReported = shouldBeReported;\n    this._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n  }\n\n  static isNomicLabsHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isNomicLabsHardhatPluginError === true;\n  }\n\n}\n\nexports.NomicLabsHardhatPluginError = NomicLabsHardhatPluginError;\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\n\nfunction applyErrorMessageTemplate(template, values) {\n  return _applyErrorMessageTemplate(template, values, false);\n}\n\nexports.applyErrorMessageTemplate = applyErrorMessageTemplate;\n\nfunction _applyErrorMessageTemplate(template, values, isRecursiveCall) {\n  if (!isRecursiveCall) {\n    for (const variableName of Object.keys(values)) {\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName\n        });\n      }\n\n      const variableTag = `%${variableName}%`;\n\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName\n        });\n      }\n    }\n  }\n\n  if (template.includes(\"%%\")) {\n    return template.split(\"%%\").map(part => _applyErrorMessageTemplate(part, values, true)).join(\"%\");\n  }\n\n  for (const variableName of Object.keys(values)) {\n    let value;\n\n    if (values[variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[variableName].toString();\n    }\n\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n\n    const variableTag = `%${variableName}%`;\n\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG, {\n        variable: variableName\n      });\n    }\n\n    template = (0, strings_1.replaceAll)(template, variableTag, value);\n  }\n\n  return template;\n}\n\nfunction assertHardhatInvariant(invariant, message) {\n  if (!invariant) {\n    throw new HardhatError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, {\n      message\n    });\n  }\n}\n\nexports.assertHardhatInvariant = assertHardhatInvariant;","map":{"version":3,"sources":["../../src/internal/core/errors.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertHardhatInvariant = exports.applyErrorMessageTemplate = exports.NomicLabsHardhatPluginError = exports.HardhatPluginError = exports.HardhatError = exports.CustomError = void 0;\nconst caller_package_1 = require(\"../util/caller-package\");\nconst strings_1 = require(\"../util/strings\");\nconst errors_list_1 = require(\"./errors-list\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nclass CustomError extends Error {\n    constructor(message, parent) {\n        // WARNING: Using super when extending a builtin class doesn't work well\n        // with TS if you are compiling to a version of JavaScript that doesn't have\n        // native classes. We don't do that in Hardhat.\n        //\n        // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        super(message);\n        this.parent = parent;\n        this.name = this.constructor.name;\n        // We do this to avoid including the constructor in the stack trace\n        if (Error.captureStackTrace !== undefined) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this._stack = this.stack ?? \"\";\n        Object.defineProperty(this, \"stack\", {\n            get: () => this[inspect](),\n        });\n    }\n    [inspect]() {\n        let str = this._stack;\n        if (this.parent !== undefined) {\n            const parentAsAny = this.parent;\n            const causeString = parentAsAny[inspect]?.() ??\n                parentAsAny.inspect?.() ??\n                parentAsAny.stack ??\n                parentAsAny.toString();\n            const nestedCauseStr = causeString\n                .split(\"\\n\")\n                .map((line) => `    ${line}`)\n                .join(\"\\n\")\n                .trim();\n            str += `\n\n    Caused by: ${nestedCauseStr}`;\n        }\n        return str;\n    }\n}\nexports.CustomError = CustomError;\nclass HardhatError extends CustomError {\n    constructor(errorDescriptor, messageArguments = {}, parentError) {\n        const prefix = `${(0, errors_list_1.getErrorCode)(errorDescriptor)}: `;\n        const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);\n        super(prefix + formattedMessage, parentError);\n        this.errorDescriptor = errorDescriptor;\n        this.number = errorDescriptor.number;\n        this.messageArguments = messageArguments;\n        this._isHardhatError = true;\n        Object.setPrototypeOf(this, HardhatError.prototype);\n    }\n    static isHardhatError(other) {\n        return (other !== undefined && other !== null && other._isHardhatError === true);\n    }\n    static isHardhatErrorType(other, descriptor) {\n        return (HardhatError.isHardhatError(other) &&\n            other.errorDescriptor.number === descriptor.number);\n    }\n}\nexports.HardhatError = HardhatError;\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\nclass HardhatPluginError extends CustomError {\n    constructor(pluginNameOrMessage, messageOrParent, parent) {\n        if (typeof messageOrParent === \"string\") {\n            super(messageOrParent, parent);\n            this.pluginName = pluginNameOrMessage;\n        }\n        else {\n            super(pluginNameOrMessage, messageOrParent);\n            this.pluginName = (0, caller_package_1.getClosestCallerPackage)();\n        }\n        this._isHardhatPluginError = true;\n        Object.setPrototypeOf(this, HardhatPluginError.prototype);\n    }\n    static isHardhatPluginError(other) {\n        return (other !== undefined &&\n            other !== null &&\n            other._isHardhatPluginError === true);\n    }\n}\nexports.HardhatPluginError = HardhatPluginError;\nclass NomicLabsHardhatPluginError extends HardhatPluginError {\n    /**\n     * This class is used to throw errors from *core* hardhat plugins. If you are\n     * developing a third-party plugin, use HardhatPluginError instead.\n     */\n    constructor(pluginName, message, parent, shouldBeReported = false) {\n        super(pluginName, message, parent);\n        this.shouldBeReported = shouldBeReported;\n        this._isNomicLabsHardhatPluginError = true;\n        Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n    }\n    static isNomicLabsHardhatPluginError(other) {\n        return (other !== undefined &&\n            other !== null &&\n            other._isNomicLabsHardhatPluginError === true);\n    }\n}\nexports.NomicLabsHardhatPluginError = NomicLabsHardhatPluginError;\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\nfunction applyErrorMessageTemplate(template, values) {\n    return _applyErrorMessageTemplate(template, values, false);\n}\nexports.applyErrorMessageTemplate = applyErrorMessageTemplate;\nfunction _applyErrorMessageTemplate(template, values, isRecursiveCall) {\n    if (!isRecursiveCall) {\n        for (const variableName of Object.keys(values)) {\n            if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n                throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n                    variable: variableName,\n                });\n            }\n            const variableTag = `%${variableName}%`;\n            if (!template.includes(variableTag)) {\n                throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n                    variable: variableName,\n                });\n            }\n        }\n    }\n    if (template.includes(\"%%\")) {\n        return template\n            .split(\"%%\")\n            .map((part) => _applyErrorMessageTemplate(part, values, true))\n            .join(\"%\");\n    }\n    for (const variableName of Object.keys(values)) {\n        let value;\n        if (values[variableName] === undefined) {\n            value = \"undefined\";\n        }\n        else if (values[variableName] === null) {\n            value = \"null\";\n        }\n        else {\n            value = values[variableName].toString();\n        }\n        if (value === undefined) {\n            value = \"undefined\";\n        }\n        const variableTag = `%${variableName}%`;\n        if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n            throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG, { variable: variableName });\n        }\n        template = (0, strings_1.replaceAll)(template, variableTag, value);\n    }\n    return template;\n}\nfunction assertHardhatInvariant(invariant, message) {\n    if (!invariant) {\n        throw new HardhatError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, { message });\n    }\n}\nexports.assertHardhatInvariant = assertHardhatInvariant;\n//# sourceMappingURL=errors.js.map"]},"metadata":{},"sourceType":"script"}