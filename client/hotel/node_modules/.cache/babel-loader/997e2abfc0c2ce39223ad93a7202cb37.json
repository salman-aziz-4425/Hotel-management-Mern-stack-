{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst mkdirp = require('../mkdirs').mkdirs;\n\nconst pathExists = require('../path-exists').pathExists;\n\nconst utimes = require('../util/utimes').utimesMillis;\n\nconst notExist = Symbol('notExist');\n\nfunction copy(src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts;\n    opts = {};\n  } else if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n\n  cb = cb || function () {};\n\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n  // Warn about using preserveTimestamps on 32-bit node\n\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`);\n  }\n\n  checkPaths(src, dest, (err, destStat) => {\n    if (err) return cb(err);\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);\n    return checkParentDir(destStat, src, dest, opts, cb);\n  });\n}\n\nfunction checkParentDir(destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest);\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err);\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb);\n    mkdirp(destParent, err => {\n      if (err) return cb(err);\n      return startCopy(destStat, src, dest, opts, cb);\n    });\n  });\n}\n\nfunction handleFilter(onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb);\n      return onInclude(src, dest, opts, cb);\n    }\n\n    return cb();\n  }, error => cb(error));\n}\n\nfunction startCopy(destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);\n  return getStats(destStat, src, dest, opts, cb);\n}\n\nfunction getStats(destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat;\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err);\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);\n  });\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb);\n  return mayCopyFile(srcStat, src, dest, opts, cb);\n}\n\nfunction mayCopyFile(srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err);\n      return copyFile(srcStat, src, dest, opts, cb);\n    });\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`));\n  } else return cb();\n}\n\nfunction copyFile(srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err);\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb);\n    });\n  }\n\n  return copyFileFallback(srcStat, src, dest, opts, cb);\n}\n\nfunction copyFileFallback(srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src);\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, {\n      mode: srcStat.mode\n    });\n    ws.on('error', err => cb(err)).on('open', () => rs.pipe(ws)).once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));\n  });\n}\n\nfunction setDestModeAndTimestamps(srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err);\n\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb);\n    }\n\n    return cb();\n  });\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb);\n\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));\n  }\n\n  return copyDir(src, dest, opts, cb);\n}\n\nfunction mkDirAndCopy(srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err);\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err);\n      return fs.chmod(dest, srcStat.mode, cb);\n    });\n  });\n}\n\nfunction copyDir(src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err);\n    return copyDirItems(items, src, dest, opts, cb);\n  });\n}\n\nfunction copyDirItems(items, src, dest, opts, cb) {\n  const item = items.pop();\n  if (!item) return cb();\n  return copyDirItem(items, item, src, dest, opts, cb);\n}\n\nfunction copyDirItem(items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  checkPaths(srcItem, destItem, (err, destStat) => {\n    if (err) return cb(err);\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err);\n      return copyDirItems(items, src, dest, opts, cb);\n    });\n  });\n}\n\nfunction onLink(destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err);\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb);\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb);\n          return cb(err);\n        }\n\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest);\n        }\n\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));\n        } // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n\n\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));\n        }\n\n        return copyLink(resolvedSrc, dest, cb);\n      });\n    }\n  });\n}\n\nfunction copyLink(resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err);\n    return fs.symlink(resolvedSrc, dest, cb);\n  });\n} // return true if dest is a subdir of src, otherwise false.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArray = path.resolve(src).split(path.sep);\n  const destArray = path.resolve(dest).split(path.sep);\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);\n}\n\nfunction checkStats(src, dest, cb) {\n  fs.stat(src, (err, srcStat) => {\n    if (err) return cb(err);\n    fs.stat(dest, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {\n          srcStat,\n          destStat: notExist\n        });\n        return cb(err);\n      }\n\n      return cb(null, {\n        srcStat,\n        destStat\n      });\n    });\n  });\n}\n\nfunction checkPaths(src, dest, cb) {\n  checkStats(src, dest, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));\n    }\n\n    return cb(null, destStat);\n  });\n}\n\nmodule.exports = copy;","map":{"version":3,"sources":["/Users/macbook/Desktop/Projects/Hotel-management-Mern-stack-/client/hotel/node_modules/hardhat/node_modules/fs-extra/lib/copy/copy.js"],"names":["fs","require","path","mkdirp","mkdirs","pathExists","utimes","utimesMillis","notExist","Symbol","copy","src","dest","opts","cb","filter","clobber","overwrite","preserveTimestamps","process","arch","console","warn","checkPaths","err","destStat","handleFilter","checkParentDir","destParent","dirname","dirExists","startCopy","onInclude","Promise","resolve","then","include","error","getStats","stat","dereference","lstat","srcStat","isDirectory","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","copyFile","mayCopyFile","unlink","errorOnExist","Error","setDestModeAndTimestamps","copyFileFallback","rs","createReadStream","on","once","ws","createWriteStream","mode","pipe","chmod","atime","mtime","mkDirAndCopy","copyDir","mkdir","readdir","items","copyDirItems","item","pop","copyDirItem","srcItem","join","destItem","readlink","resolvedSrc","cwd","symlink","resolvedDest","code","isSrcSubdir","copyLink","srcArray","split","sep","destArray","reduce","acc","current","i","checkStats","stats","ino","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\n\nconst notExist = Symbol('notExist')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  checkPaths(src, dest, (err, destStat) => {\n    if (err) return cb(err)\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n    return checkParentDir(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb)\n      return onInclude(src, dest, opts, cb)\n    }\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  checkPaths(srcItem, destItem, (err, destStat) => {\n    if (err) return cb(err)\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest, cb) {\n  fs.stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n    fs.stat(dest, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})\n        return cb(err)\n      }\n      return cb(null, {srcStat, destStat})\n    })\n  })\n}\n\nfunction checkPaths (src, dest, cb) {\n  checkStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const {srcStat, destStat} = stats\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    return cb(null, destStat)\n  })\n}\n\nmodule.exports = copy\n"]},"metadata":{},"sourceType":"script"}